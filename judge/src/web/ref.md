
# C 문법 오류 개념 레퍼런스


---

## 함수 선언 누락
📌 개념 설명

- 함수를 호출하기 전에 선언하지 않으면 `"implicit declaration of function"` 오류가 발생합니다.
- 함수 선언은 보통 헤더 파일에 `void greet();` 처럼 작성하거나, 본문 위에 함수 원형을 명시해야 합니다.

---

### ✅ 올바른 예시

```c
void greet();  // 선언

int main() {
    greet();    // 선언된 함수 호출
    return 0;
}

void greet() {
    printf("Hi");
}

```

---

### ❌ 잘못된 예시

```c
int main() {
    greet(); // 오류: 선언 없이 호출
    return 0;
}

void greet() {
    printf("Hi");
}

```

---


## 표현식 누락
📌 개념 설명

- 조건문, 반복문 또는 계산에서 필요한 표현식이 누락되면 `"expected expression"` 오류가 발생합니다.
- 이는 세미콜론을 잘못 사용했거나 연산 대상이 빠진 경우입니다.

---

### ❌ 잘못된 예시

```c
int main() {
    if () {  // 오류: 조건 표현식 없음
        printf("오류");
    }

    int x = ; // 오류: 대입값 없음
}

```

---


## 정수/실수 리터럴 오류
📌 개념 설명

- 숫자 뒤에 잘못된 접미사(예: `10z`)를 붙이면 `"invalid suffix"` 오류가 발생합니다.
- C에서는 정수형 접미사로 `U`, `L`, `LL` 등만 허용되며, 부동소수점에는 `f`, `F` 등이 사용됩니다.

---

### ❌ 잘못된 예시

```c
int x = 10z;   // 오류: z는 유효한 접미사가 아님
float y = 1.2q; // 오류: q는 허용되지 않음

```

---

## 배열 접근 오류

📌 개념 설명
- 배열을 사용할 때 잘못된 방식으로 접근하면 컴파일 오류 또는 런타임 오류가 발생할 수 있습니다.
- 오류는 크게 두 가지 유형으로 나뉩니다:

| 유형 | 설명 | 오류 시점 |
| --- | --- | --- |
| 배열이 아닌 값에 [] 사용 | 정수, 구조체, 초기화되지 않은 포인터 등 | 컴파일 오류 |
| 배열이지만 인덱스 초과 | 유효 범위 밖의 인덱스로 접근 | 런타임 오류 |
- C에서는 배열과 포인터가 유사하게 동작하지만, 타입과 초기화 여부를 반드시 확인해야 합니다.

---

### ✅ 올바른 예시

```c
int arr[5];
arr[0] = 10;
arr[4] = 50; // OK: 마지막 인덱스 접근

for (int i = 0; i < 5; i++) {
    printf("%d ", arr[i]); // OK
}

char str[] = "Hello";
printf("%c\n", str[0]); // OK: 문자열 배열 접근

int *p = arr;
printf("%d\n", p[2]); // OK: 포인터로 인덱싱
```

---

### ❌ 잘못된 예시 (인덱싱 대상이 배열이 아님)

```c
int x = 10;
x[0] = 5; // ❌ 오류: 정수형 변수에 인덱싱 사용

struct Student { int id; };
struct Student s;
s[0].id = 1; // ❌ 오류: 구조체는 배열이 아님

int *ptr;
ptr[0] = 3; // ❌ 경고/오류: 초기화되지 않은 포인터 사용
```

---

### ❌ 잘못된 예시 (배열 범위 초과)

```c
int arr[3];
arr[3] = 100; // ❌ 오류: 유효 인덱스는 0~2까지

for (int i = 0; i <= 3; i++) {
    printf("%d ", arr[i]); // ❌ i==3일 때 오류 가능성
}
```

---

💡 보충 설명

- 인덱싱은 배열 또는 유효한 포인터에만 적용할 수 있습니다.
- arr[n] 접근 시 0 <= n < 배열 크기를 항상 지켜야 하며, 초과 시 Undefined Behavior가 발생합니다.
- int *p = NULL; p[0] = 1; 같은 코드는 컴파일은 되지만 실행 중 세그멘테이션 오류(segfault)를 유발할 수 있습니다.

---

🧠 체크리스트

- ✅ [] 연산자는 배열 또는 유효한 포인터에만 사용
- ✅ 인덱스는 반드시 0 이상, 배열 크기 미만
- ✅ 포인터는 반드시 초기화 후 사용
- ❌ 정수형 변수, 구조체에 [] 사용 금지
- ❌ 배열 길이보다 큰 인덱스로 접근하지 않기
- ❌ 반복문에서 종료 조건 i < size를 항상 확인


---

## 연산자 사용 오류
📌 개념 설명

- 연산자의 좌변 또는 우변 타입이 잘못되었거나, 타입 간 연산이 불가능할 경우 `"invalid operands to binary expression"` 오류가 발생합니다.

---

### ❌ 잘못된 예시

```c
int x = 10;
char *str = "hello";
int result = x + str; // 오류: 정수 + 문자열 포인터 연산 불가능

```

---

## 함수 반환
📌 개념 설명

- 모든 함수는 선언된 반환 타입(return type)에 따라 `return` 문을 사용해야 합니다.
- `int`, `float`, `char` 등 반환 타입이 있는 함수는 값을 반환해야 하며, `void` 함수는 값을 반환하면 오류가 발생합니다.
- `return` 문은 모든 분기에서 빠짐없이 작성되어야 하며, 조건문 안에만 존재할 경우 조건을 만족하지 않을 때 반환되지 않는 문제가 발생합니다.

---

### ✅ 올바른 예시

```c
int getMax() {
	return 100; // int 함수는 반드시 값을 반환
}
void greet() {
	printf("Hello!\\n");
	return; // void 함수는 값 없이 return만 가능
}
int compare(int a) {
    if (a > 0) {
        return 1;
    } else {
        return 0;
    }
}

```

---

### ❌ 잘못된 예시

```c
void greet() {
    return 1; // 오류: void 함수에서 값을 반환
}
int getMin() {
// 오류: 반환값 없음
}
int check(int x) {
    if (x > 0) return 1;    // else 조건에 return 없음 → 컴파일 경고 또는 오류
}

```

---



## 변수 선언
📌 개념 설명

- C 언어에서는 변수를 반드시 사용 전에 선언해야 하며, 타입과 변수 이름을 명확히 지정해야 합니다.
- 선언하지 않은 변수를 사용하면 `"undeclared identifier"` 또는 `"implicit declaration"` 오류가 발생합니다.
- 지역 변수는 선언된 블록(scope) 내에서만 사용할 수 있으며, 유효 범위를 벗어나면 접근할 수 없습니다.
- 또한, 변수를 초기화하지 않고 사용하는 경우 쓰레기 값(임의의 메모리 값) 으로 인해 예측 불가능한 동작이 발생할 수 있습니다.

---

### ✅ 올바른 예시

```c
int main() {
    int x = 10; // 선언과 초기화
    printf("%d\\n", x);
    int y;
    y = 20; // 선언 후 값 할당
    if (x < y) {
         int diff = y - x; // 블록 내부에서만 유효
            printf("차이: %d\\n", diff);
        }
        return 0;
        }

```

---

### ❌ 잘못된 예시

```c
int main() {
    x = 10; // 오류: 선언되지 않은 변수 x
    if (1) {
        int a = 5;
      }
       printf("%d", a); // 오류: 지역 변수 a는 if 블록 바깥에서 접근 불가
       int b;
       printf("%d", b); // 논리 오류: b는 초기화되지 않았음
       return 0;
    }

```

---



## 입출력 형식 지정자
📌 개념 설명

- `scanf()`와 `printf()`는 C 언어에서 사용하는 대표적인 표준 입출력 함수 입니다.
- 이 함수들은 반드시 형식 지정자(format specifier) 를 사용하여 입력 또는 출력할 변수의 타입을 명시해야 합니다.
- 특히 `scanf()`에서는 입력받은 값을 변수에 저장해야 하므로 **변수의 주소**를 전달해야 하며, 변수 앞에 `&` 주소 연산자가 필요합니다.
- 형식 지정자와 변수 타입이 일치하지 않으면 잘못된 값이 입력되거나, 런타임 오류가 발생할 수 있습니다.

🧠 참고:

| 데이터 타입 | 형식 지정자 |
| --- | --- |
| `int` | `%d` |
| `float` | `%f` |
| `char` | `%c` |
| `char[]` 문자열 | `%s` |

### ✅ 올바른 예시

```c
int x;
float y;
char c;
char str[100];
scanf("%d", &x);  // 정수 입력
scanf("%f", &y);  // 실수 입력
scanf(" %c", &c); // 문자 입력 (공백 문자 방지 위해 앞에 space)
scanf("%s", str); // 문자열 입력 (& 없이 배열 이름만 전달)
printf("정수: %d\\n", x);
printf("실수: %.2f\\n", y);
printf("문자: %c\\n", c);
printf("문자열: %s\\n", str);

```

---

### ❌ 잘못된 예시

```c
int x;
scanf("%d", x); // 오류: 주소 연산자(&) 없음

float y;
scanf("%d", &y); // 오류: 형식 지정자와 타입 불일치

char name[20];
scanf("%s", &name); // 오류: 문자열은 배열 이름만 써야 함 (& 불필요)

```

---



## 포인터
📌 개념 설명

- 포인터는 다른 변수의 주소를 저장하는 변수 입니다. 를 사용하여 선언하며, `&`로 주소를 얻을 수 있습니다.
- 선언한 포인터는 반드시 초기화 후 사용해야 하며, 초기화되지 않은 포인터를 역참조(`p`)하면 Segmentation fault 등 심각한 오류가 발생할 수 있습니다.
- 포인터 타입이 다르면 잘못된 주소 계산이나 정렬 오류 등이 발생할 수 있으므로, 항상 올바른 타입으로 선언해야 합니다.
- 포인터는 배열과 밀접한 관계가 있으며, 동적 메모리 할당 시에도 많이 사용됩니다.

---

### ✅ 올바른 예시

```c
int x = 10;
int *p = &x; // x의 주소를 p에 저장
printf("x의 값: %d\\n", *p); // 포인터 역참조를 통해 값 접근
*p = 20; // 포인터를 통해 값 수정
printf("x의 새로운 값: %d\\n", x);

```

---

### ❌ 잘못된 예시

```c
int *p;
*p = 10; // 오류: 초기화되지 않은 포인터를 역참조 (Segmentation fault)
float f = 3.14;
int *q = &f; // 경고 또는 오류: 타입 불일치 (float → int*)

```

---

💡보충 설명

- 는 포인터 선언 시에는 포인터임을 의미하고, 사용 시에는 역참조를 의미합니다.
- `&`는 변수의 주소를 가져오는 연산자입니다.

📎 예:

```c
int a = 5;
int *ptr = &a;   // 선언: ptr은 int형 변수의 주소를 가짐
printf("%d", *ptr); // 출력: ptr이 가리키는 변수의 값

```

---



## 세미콜론 누락
📌 개념 설명

- C 언어는 세미콜론 `;`을 기준으로 문장의 끝을 구분합니다.
- 세미콜론이 빠지면 컴파일러는 문장의 경계를 알 수 없어 `"expected ';'"`, `"syntax error"` 등의 컴파일 오류를 발생시킵니다.
- 특히 여러 문장이 연속될 때 세미콜론을 빼먹으면 다음 줄의 코드가 문법적으로 잘못 해석됩니다.
- 조건문, 반복문, 함수 정의와 달리, 변수 선언과 대입문은 반드시 세미콜론으로 끝나야 합니다.

---

### ✅ 올바른 예시

```c
int main() {
	int x = 10;
	int y = 20;
	x = x + y;
	printf("%d\\n", x);
	return 0;
}

```

---

### ❌ 잘못된 예시

```c
int main() {
    int x = 10  // ❌ 세미콜론 없음
    int y = 20;
    printf("%d\n", x)
    return 0;
}

```

---

💡 **보충 설명**

- 세미콜론은 조건문이나 반복문 블록 자체에는 필요 없지만, 그 안에 들어가는 실행 문장에는 필요합니다.
- 아래와 같이 조건문을 한 줄로 작성할 경우도 세미콜론은 꼭 필요합니다:

```c
if (x > 0) printf("양수입니다\\n");  // printf 뒤에는 세미콜론!

```

---



## 비교 연산자
📌 개념 설명

- C 언어에서 `==`는 비교 연산자이고, `=`는 대입 연산자입니다.
- 조건문(`if`, `while` 등)에서는 두 값이 같은지를 비교할 때 반드시 `==`를 사용해야 하며, `=`를 쓰면 의도치 않은 대입이 발생합니다.
- 이외에도 `!=` (같지 않다), `<`, `>`, `<=`, `>=` 등의 다양한 비교 연산자가 있으며, 논리 연산자 `&&`, `||` 와 함께 자주 사용됩니다.
- 잘못된 비교 연산자의 사용은 프로그램 흐름을 완전히 왜곡시킬 수 있습니다.

---

### ✅ 올바른 예시

```c
int x = 5, y = 10;
if (x == y) {
    printf("x와 y는 같습니다\\n");
    }
else {
    printf("x와 y는 다릅니다\\n");
    }
 if (x != 0 && y > 5) {
     printf("조건을 만족합니다\\n");
    }

```

---

### ❌ 잘못된 예시

```c
int a = 3, b = 3;
if (a = b) { // 오류: a에 b를 대입하고 항상 true
	printf("항상 실행됩니다\\n");
	}
if (a ! b) {
	// 오류: != 대신 !b (논리 부정) + 문법 오류
	printf("문법 오류 발생\\n");
	}

```

---

💡 보충 설명
- `if (a = b)`는 a에 b를 대입한 후, a가 0이 아니면 true로 평가됩니다.
- 대부분의 컴파일러는 `=`와 `==` 혼동 시 경고를 출력하지만, 논리 오류를 방지하려면 반드시 `==`를 써야 합니다.

---



## 무한 루프 및 루프 조건
📌 개념 설명

- 반복문(`for`, `while`, `do while`)은 특정 조건을 만족하는 동안 코드를 반복 실행합니다.
- 종료 조건을 명확히 설정하지 않거나, 항상 참인 조건을 넣으면 무한 루프가 발생합니다.
- 의도하지 않은 무한 루프는 프로그램이 멈추지 않는 버그를 야기합니다.
- `break`, `continue` 같은 제어문을 잘못 사용하면 반복 흐름이 왜곡될 수 있습니다.
- 루프의 초기화, 조건, 증감이 제대로 작동하는지도 항상 점검해야 합니다.

---

### ✅ 올바른 예시

```c
int i = 0;
while (i < 5) {
    printf("i = %d\\n", i);
    i++;  // 종료 조건으로 향함
 }// break 사용 예시
 for (int j = 0; j < 10; j++) {
     if (j == 3) break;  // 반복 중단
     printf("j = %d\\n", j);
    }// continue 사용 예시
 for (int k = 0; k < 5; k++) {
       if (k == 2) continue;  // 2는 건너뜀
       printf("k = %d\\n", k);
    }

```

---

### ❌ 잘못된 예시

```c
int i = 0;
while (1) {
    printf("%d ", i);    // 종료 조건 없음 → 무한 루프
  }
for (int j = 0; j < 5; j++) {
    continue;
}
printf("j = %d\n", j); // 루프 바깥 출력

```

---

💡 보충 설명
- `while (1)`은 의도적으로 무한 루프를 만들 때 자주 사용되지만, 반드시 `break` 등을 통해 탈출 조건이 있어야 합니다.
- `continue`는 해당 반복의 나머지를 건너뛰고 다음 반복으로 이동합니다.
- `for`나 `while`에서 중괄호 `{}`를 생략하면 단 한 줄만 반복에 포함되므로, 들여쓰기만으로 코드 블록을 구분하면 위험합니다.

---



## 괄호 닫힘 오류
📌 개념 설명

- 조건문, 반복문, 함수 선언·호출에서 사용하는 괄호 `()`, 중괄호 `{}`, 대괄호 `[]`는 반드시 쌍을 이루어야 합니다.
- 괄호가 열리고 닫히지 않으면 컴파일러는 문장의 경계를 파악하지 못해 문법 오류(syntax error) 를 발생시킵니다.
- 특히 중괄호 `{}`가 누락되면 조건문이나 반복문에 포함되어야 할 코드가 의도와 다르게 실행되는 경우가 많습니다.
- 코드 자동 들여쓰기에 의존하지 말고, 명시적으로 괄호를 사용하는 습관을 들이는 것이 좋습니다.

---

### ✅ 올바른 예시

```c
int main() {
    int x = 5;
    if (x > 0) {
         printf("양수입니다\\n");
       }
    for (int i = 0; i < 3; i++) {
         printf("i: %d\\n", i);
      }
       return 0;
  }

```

---

### ❌ 잘못된 예시

```c
int main() {
    int x = 5;
    if (x > 0 {  // 오류: 괄호 닫힘 누락
         printf("양수입니다\\n");
         for (int i = 0; i < 3; i++ // 오류: 괄호 닫힘 누락
         printf("i: %d\\n", i);
            return 0; // 이 줄도 오류 가능성 있음 (위 문법이 깨졌기 때문)
            }

```

---

💡 보충 설명
- 괄호 문제는 복잡한 조건문이나 다중 반복문에서 특히 많이 발생합니다.
- IDE의 자동 괄호 매칭 기능 또는 문법 강조 도구를 활용하면 괄호 오류를 쉽게 방지할 수 있습니다.

---



## 구조체 사용 오류
📌 개념 설명

- 구조체(`struct`)는 여러 개의 서로 다른 타입의 데이터를 하나로 묶는 사용자 정의 자료형입니다.
- 구조체를 사용하기 위해서는 먼저 구조체의 정의(struct 정의)를 작성해야 합니다.
- 구조체 이름만 선언하고 정의를 생략한 경우, 크기를 알 수 없어 메모리를 할당할 수 없으므로 오류가 발생합니다.
- 또한 구조체 변수를 사용할 때는 `struct` 키워드를 함께 사용하거나, `typedef`로 별칭을 선언해야 합니다.

---

### ✅ 올바른 예시

```c
// 구조체 정의
struct Student {
    int id;
    char name[20];
};  // 구조체 정의 끝에는 세미콜론 필요
int main() {
    struct Student s1;
    s1.id = 2023;
    strcpy(s1.name, "Alice");
    printf("ID: %d, 이름: %s\\n", s1.id, s1.name);
    return 0;
  }

```

✅ `typedef`를 활용한 간결한 방식:

```c
typedef struct {
    int age;
    float height;
  }Person;
int main() {
    Person p1;
    p1.age = 25;
    p1.height = 175.5;
    return 0;
  }

```

---

### ❌ 잘못된 예시

```c
struct Student;
Student s1;  // 오류: 구조체의 정의 없이 사용
s1.id = 1001; // 오류: 구조체 멤버에 접근할 수 없음

```

---

💡 보충 설명
- 구조체 정의 없이 사용하려는 코드는 `"incomplete type"` 오류를 발생시킵니다.
- `#include <string.h>` 없이 `strcpy()`를 사용할 경우에도 오류가 발생할 수 있습니다.
- 구조체 포인터 사용 시 `>` 연산자를 사용하여 멤버에 접근해야 합니다.

---



## 메모리 동적 할당 오류
📌 개념 설명

- C 언어에서 `malloc()`, `calloc()`, `realloc()` 등을 사용하면 런타임 중에 메모리를 동적으로 할당할 수 있습니다.
- 동적 할당을 사용하려면 반드시 `#include <stdlib.h>`를 포함해야 하며, 반환값은 적절한 포인터 타입으로 형 변환(캐스팅)해야 합니다.
- 메모리 할당 실패 시 `malloc()`은 `NULL`을 반환하므로, 반드시 NULL 체크를 해주는 것이 좋습니다.
- 또한, 사용이 끝난 동적 메모리는 반드시 `free()` 함수를 사용하여 명시적으로 해제해야 메모리 누수를 방지할 수 있습니다.

---

### ✅ 올바른 예시

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *arr = (int *)malloc(sizeof(int) * 5); // 동적 할당

    if (arr == NULL) {
        printf("메모리 할당 실패\\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        arr[i] = i * 2;
    }

    for (int i = 0; i < 5; i++) {
        printf("%d ", arr[i]);
    }

    free(arr); // 메모리 해제
    return 0;
}

```

---

### ❌ 잘못된 예시

```c
int *arr;
arr = malloc(sizeof(int) * 5);  // 오류: stdlib.h 누락, 캐스팅 없음

arr[0] = 10; // NULL 체크 없음 → 할당 실패 시 세그멘테이션 오류

// free(arr); 없음 → 메모리 누수 발생

```

---

💡 보충 설명
- C에서는 가비지 컬렉션이 없기 때문에 메모리를 직접 관리해야 하며,

`malloc()`으로 할당한 모든 메모리는 `free()`로 해제해야 안전합니다.

- `calloc()`은 초기값을 0으로 설정하며, `realloc()`은 기존 포인터의 크기를 변경할 수 있습니다.

---



## 함수 정의 중복
📌 개념 설명

- C 언어에서는 동일한 이름을 가진 함수(특히 매개변수가 동일한 함수)를 여러 번 정의할 수 없습니다.
- 함수 중복 정의는 컴파일 시 `"redefinition of function"` 또는 `"multiple definition"` 오류를 발생시킵니다.
- 이 오류는 주로 다음과 같은 경우에 발생합니다:
- 실수로 같은 함수 내용을 두 번 작성했을 때
- 헤더 파일에 함수 정의를 넣고 여러 파일에서 `#include` 했을 때
- 링크 단계에서 동일한 함수가 두 객체 파일에 중복되어 존재할 때
- 함수 중복 정의를 피하려면 헤더에는 선언만 (`extern`), 구현은 하나의 `.c` 파일에만 작성해야 합니다.

---

### ✅ 올바른 예시

```c
// header.h
#ifndef HEADER_H
#define HEADER_H

void greet(); // 함수 선언만

#endif

// main.c
#include "header.h"
#include <stdio.h>

void greet() {
    printf("Hello!\\n");
}

int main() {
    greet();
    return 0;
}

```

---

### ❌ 잘못된 예시

```c
int main() {
    printf("Hello\\n");
}

int main() { // 오류: main 함수 중복 정의
    printf("World\\n");
}

```

또는

```c
// header.h
void greet() {
    printf("Hi\\n");
}

// main.c와 util.c가 둘 다 header.h를 포함할 경우 중복 정의 오류 발생

```

---

💡 보충 설명
- `inline` 함수나 `static` 함수는 예외적으로 중복 정의를 허용하지만, 그 외에는 항상 함수 정의는 하나만 존재해야 합니다.
- 함수의 이름 충돌을 방지하려면 정확한 모듈 분리와 헤더 보호 매크로 (`#ifndef`, `#define`) 사용이 필수입니다.

---


---

## 선언 위치 오류
📌 개념 설명

- C 언어에서는 변수나 문장은 반드시 유효한 위치(문맥) 에 선언되어야 합니다.
- 예를 들어, 함수 외부에는 실행문을 쓸 수 없고, 블록 내부의 변수는 해당 블록 외부에서 사용할 수 없습니다.
- 또한 선언 전 사용이나, 제어문 외부에서 제어문을 사용하는 경우는 컴파일 오류를 발생시킵니다.
- 변수의 유효 범위(scope) 는 선언 위치에 따라 결정되며, 이를 명확히 이해하고 코딩해야 합니다.

---

### ✅ 올바른 예시

```c
int global = 100; // 전역 변수

int main() {
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("%d ", i);
    }

    if (n > 0) {
        int square = n * n;
        printf("제곱: %d\\n", square);
    }

    return 0;
}

```

---

### ❌ 잘못된 예시

```c
int N;
for (int i = 0; i < N; i++) {  // 오류: 함수 외부에는 실행문 작성 불가
    printf("%d", i);
}

if (1) {
    int x = 10;
}
printf("%d", x); // 오류: x는 블록 내부에서만 유효

value = 5; // 오류: value 선언 전 사용

```

---

💡 보충 설명
- 전역 변수(Global variable): 함수 외부에서 선언되며 파일 전체에 걸쳐 유효
- 지역 변수(Local variable): 함수 또는 블록 내에서 선언되며, 해당 블록에서만 유효
- 지역 변수는 선언된 위치보다 앞에서는 사용할 수 없습니다.

---



---

## 전처리기 오류
📌 개념 설명

- 전처리기는 컴파일 전에 수행되는 명령어로, `#include`, `#define`, `#ifdef` 등이 대표적입니다.
- 전처리기 명령은 정확한 문법을 따라야 하며, 잘못 작성하면 컴파일 이전 단계에서 에러가 발생합니다.
- 특히 `#define`에서는 매크로 이름이 숫자로 시작할 수 없고, 공백이나 특수문자가 포함되면 안 됩니다.
- `#include`는 문자열 또는 `<...>` 형식으로 작성되어야 하며, 파일명이 잘못되었거나 존재하지 않으면 오류가 납니다.

---

### ✅ 올바른 예시

```c
#include <stdio.h>      // 표준 라이브러리 포함
#define MAX 100         // 매크로 정의

int main() {
    int arr[MAX];
    printf("크기: %d\\n", MAX);
    return 0;
}

```

---

### ❌ 잘못된 예시

```c
#define 10 MAX      // 오류: 숫자로 시작하는 매크로 이름
#define MAX-VALUE 50 // 오류: 매크로 이름에 특수문자 사용

#include stdio.h    // 오류: 따옴표나 꺽쇠가 없음
#include "missing.h" // 오류: 해당 파일이 존재하지 않음

```

---

💡 보충 설명
- 전처리기는 컴파일러가 코드를 번역하기 전에 실행되므로, 오류가 발생하면 컴파일 자체가 진행되지 않습니다.
- `#define` 매크로는 상수 대체뿐 아니라 간단한 함수처럼 매개변수를 받을 수도 있습니다:

```c
#define SQUARE(x) ((x)*(x))

```

- 매크로를 사용할 때는 괄호를 활용하여 우선순위 오류를 방지하세요.

---



## 표준 함수 오용
📌 개념 설명

- C 언어에서 제공하는 표준 함수(`printf`, `scanf`, `strlen`, `malloc` 등)는 정해진 형태로만 사용 가능합니다.
- C에는 `print()` 같은 함수는 존재하지 않으며, 이를 호출하려 하면 “implicit declaration” 또는 “undefined reference” 오류가 발생합니다.
- 또한 표준 함수를 사용하려면 해당 함수를 선언한 헤더 파일을 반드시 포함해야 하며,

이를 생략할 경우 `"implicit declaration of function"` 또는 `"undefined reference"` 오류가 발생합니다.

- 반환값이 있는 함수(`printf`, `strlen`, `scanf`, `malloc` 등)의 결과를 무시하거나 잘못 처리하면 논리적 오류도 발생할 수 있습니다.

---

### ✅ 올바른 예시

```c
#include <stdio.h>  // printf 선언을 위한 필수 헤더

int main() {
    int len = printf("Hello, world!\\n");  // 반환값: 출력한 문자 수
    printf("총 %d자 출력됨\\n", len);
    return 0;
}

```

---

### ❌ 잘못된 예시

```c
print("Hello");  // 오류: C에는 print 함수 없음

int main() {
    strlen("hi");  // 오류: string.h 헤더 누락
}

```

---

💡 **보충 설명**

- `printf()`는 `stdio.h`에 선언되어 있으며, 반환값은 출력된 문자 수입니다.
- `malloc()`은 `stdlib.h`, `strlen()`은 `string.h`, `sqrt()`는 `math.h` 등 함수마다 필요로 하는 헤더가 다릅니다.

---



## 함수 인자 순서 오류
📌 개념 설명

- C에서 함수를 호출할 때는 정의된 함수의 인자 순서 및 타입을 정확히 일치시켜야 합니다.
- 인자의 개수, 순서, 타입이 하나라도 일치하지 않으면 `"incompatible pointer type"`, `"too few arguments"` 등의 컴파일 오류가 발생하거나,

컴파일은 되더라도 논리적 오류나 런타임 크래시로 이어질 수 있습니다.

- 특히 포인터 인자, 배열 인자 등은 타입 일치가 매우 중요하며, 순서가 바뀌면 결과가 전혀 달라질 수 있습니다.

---

### ✅ 올바른 예시

```c
unsigned int dot_product(unsigned int *a, unsigned int *b, int n) {
    unsigned int sum = 0;
    for (int i = 0; i < n; i++) {
        sum += a[i] * b[i];
    }
    return sum;
}

int main() {
    unsigned int A[3] = {1, 2, 3};
    unsigned int B[3] = {4, 5, 6};
    int n = 3;

    unsigned int result = dot_product(A, B, n);  // 순서, 타입 일치
    printf("결과: %u\\n", result);
    return 0;
}

```

---

### ❌ 잘못된 예시

```c
unsigned int dot_product(unsigned int *a, unsigned int *b, int n);

int main() {
    unsigned int A[3] = {1, 2, 3};
    unsigned int B[3] = {4, 5, 6};
    int n = 3;

    unsigned int result = dot_product(n, A, B); // 오류: 인자 순서 불일치
    printf("결과: %u\\n", result);
}

```

---

💡 보충 설명
- 함수 정의를 헷갈리지 않도록 함수 원형(prototype)을 명확히 선언하고,

코드 상단 또는 별도 헤더 파일로 관리하는 것이 좋습니다.

- 구조체를 인자로 넘길 때도 멤버 순서나 타입을 정확히 맞춰야 하며,

컴파일은 되더라도 값이 틀어질 수 있으니 주의해야 합니다.

---
## 상수 수정 오류

📌 개념 설명

- const 키워드로 선언된 변수는 **읽기 전용 변수**입니다.
- 일반적으로 상수 선언은 코드의 안정성과 가독성을 높이기 위해 사용됩니다.

---

### ✅ 올바른 예시

```c
const int MAX = 100;
printf("%d\n", MAX);
```

---

### ❌ 잘못된 예시

```c
const int MAX = 100;
MAX = 200; // ❌ 오류: 상수는 수정할 수 없음
```

---

💡 보충 설명

- const 포인터와 일반 포인터는 다르게 동작하므로, 선언 시 위치에 따라 의미가 달라집니다:

```c
const int *p;   // p가 가리키는 값은 변경 불가
int *const p;   // p 자체는 변경 불가 (주소 고정)
```

---

## 형 변환 오류

📌 개념 설명

- 서로 다른 자료형 간의 자동 형 변환(암시적 형 변환)은 컴파일러 경고를 유발할 수 있습니다.
- 특히 float → int, double → int 등의 변환은 값 손실이 발생할 수 있습니다.
- 명시적 형 변환(casting)을 사용하면 이러한 경고를 방지할 수 있지만, 의미 없는 변환은 피해야 합니다.

---

### ✅ 올바른 예시

```c
float pi = 3.14;
int value = (int)pi;
printf("%d\n", value);
```

---

### ❌ 잘못된 예시

```c
float pi = 3.14;
int value = pi; // ❌ 경고 또는 오류: 암시적 형 변환
```

---

💡 보충 설명

- 암시적 형 변환은 묵시적으로 타입을 바꾸는 것이며, C는 보통 작은 타입에서 큰 타입으로의 변환은 허용하나, 큰 → 작은 타입 변환은 조심해야 합니다.
- 특히 포인터 간 변환은 오류 또는 정의되지 않은 동작(UB)을 유발할 수 있습니다.

---


## **런타임 오류**

📌 **개념 설명**

- 런타임 오류는 컴파일 시점에는 발생하지 않지만, **프로그램 실행 도중에 발생하는 오류**입니다.
- 대표적인 원인은 다음과 같습니다:
    - 유효하지 않은 메모리 접근 (예: 잘못된 배열 인덱스, NULL 포인터 역참조 등)
    - 무한 루프 등으로 인한 과도한 메모리/시간 사용
    - 동적 할당 후 해제된 메모리에 접근하는 경우

---

### **✅ 먼저 확인해보세요**

다음 항목에서 발생한 문제일 수 있습니다. 해당 섹션도 함께 참고하세요:

- [배열 접근 오류](http://192.168.0.85/reference.php#배열-접근-오류)
- [포인터](http://192.168.0.85/reference.php#포인터)

---

💡 **보충 설명**

- 대부분의 런타임 오류는 배열 또는 포인터 접근이 잘못되었을 가능성이 높습니다.
- 또한 Segmentation fault, bus error 등도 런타임 오류이며, 대부분 메모리 관련 실수에서 발생합니다.

---

🧠 **추가 체크리스트**

- ✅ 배열 인덱스가 범위를 초과하지 않았는가?
- ✅ 포인터가 유효한 메모리를 가리키고 있는가?
- ✅ 동적 할당 후 적절히 해제했는가?
- ✅ NULL 포인터에 접근하지 않았는가?

---

## **알 수 없는 오류**

📌 **개념 설명**

- 컴파일러 또는 런타임에서 출력한 오류 메시지가 현재 시스템의 오류 분류 기준에 일치하지 않을 경우, “알 수 없는 오류”로 처리됩니다.
- 이는 새로운 오류 유형이거나 아직 등록되지 않은 오류 패턴일 수 있습니다.

---
💬 **알림**

- 😕 오류 메시지를 분석할 수 없었습니다.
- 🔧 혹시 위 메시지가 이해되지 않거나, 시스템에서 자동으로 인식하지 못하는 경우라면 **담당자에게 오류 메시지를 공유** 해주세요!!
- 📬 함께 시스템을 더 완벽하게 만들어갈 수 있습니다.
---

🧠 **스스로 확인해볼 수 있는 것**

- 오류 메시지를 복사해 검색 엔진이나 공식 문서에서 찾아보기
- 최근 추가한 코드를 중심으로 다시 검토
- 컴파일러 버전이나 설정 차이로 인한 경고/오류일 수 있음

---
